
use parser::ast::{self, Template, NodeType, ContentNodeType, ExprValue, ExprOp, ActionOpNode};
use parser::store::{DefaultScopeNodeType, ScopeNodeType, ActionStateExprType};
use parser::api::{self, ApiNodeType, MethodType};
use parser::loc::Loc;
use parser::token::{self, Token};
use parser::util::allocate_element_key;

grammar;

pub Template: Template = {
    <children:Loc<NodeType>*> => Template { children: children }
};

NodeType: NodeType = {
    UseStmtNode,
    ComponentDefinitionNode,
    StoreNode,
    <content:ContentNodeType> => NodeType::ContentNode(content)
};

ContentNodeType : ContentNodeType = {
    ElementNode,
    <num:LitNum> => ContentNodeType::ExpressionValueNode(ExprValue::LiteralNumber(num)),
    <lit:LitStr> => ContentNodeType::ExpressionValueNode(ExprValue::LiteralString(lit)),
    "{" <expr:ExprValue> "}" => ContentNodeType::ExpressionValueNode(expr),
};

// Store defines a default scope which restricts the type of nodes allowed
StoreNode : NodeType =
{
    StoreKeyword "{" <children:DefaultScopeNodeType*> "}" => NodeType::StoreNode(children)
};

UseStmtNode : NodeType =
{
    UseKeyword <package:Id> ";" =>
    {
        let package = package.into();

        NodeType::UseStmtNode(
            ast::UseStmtType {
                package: package
            }
        )
    }
};

ComponentDefinitionNode: NodeType =
{
    ComponentKeyword <name:Id> "{"
        <children:NodeType*>
    "}" =>
    {
        let definition_name = name.into();

        NodeType::ComponentDefinitionNode(
            ast::ComponentDefinitionType {
                name: definition_name,
                inputs: None,
                children: Some(children)
            }
        )
    },
    ComponentKeyword <name:Id> "(" <inputs:CommaList<Id>> ")" "{"
        <children:NodeType*>
    "}" =>
    {
        NodeType::ComponentDefinitionNode(
            ast::ComponentDefinitionType {
                name: name.into(),
                inputs: Some(inputs),
                children: Some(children)
            }
        )
    }
};

ExprOp : ExprOp =
{
    "+" => ExprOp::Add,
    "-" => ExprOp::Sub,
    "*" => ExprOp::Mul,
    "/" => ExprOp::Div
};

ExprValue : ExprValue =
{
    <l:ExprValue> "+" <r:ExprFactor> => ExprValue::Expr(ExprOp::Add, Box::new(l), Box::new(r)),
    <l:ExprValue> "-" <r:ExprFactor> => ExprValue::Expr(ExprOp::Sub, Box::new(l), Box::new(r)),
//    "|" <attrs:("(" <AtLeastOne<Id>> ")")?> "|" "{" <action_ops:ActionOpNode*> "}" => ExprValue::Action(attrs, Some(action_ops)),
    ExprFactor
};

ExprFactor : ExprValue =
{
    <l:ExprFactor> "*" <r:ExprTerm> => ExprValue::Expr(ExprOp::Mul, Box::new(l), Box::new(r)),
    <l:ExprFactor> "/" <r:ExprTerm> => ExprValue::Expr(ExprOp::Div, Box::new(l), Box::new(r)),
    ExprTerm
};

ExprTerm : ExprValue =
{
    <n:LitNum> => ExprValue::LiteralNumber(n),
    "(" <ExprValue> ")",
    ValueKeyword => ExprValue::DefaultVariableReference,
    <ident:Id> => ExprValue::VariableReference(ident.into()),
    <s:LitStr> => ExprValue::LiteralString(s),
};

ActionOpNode: ActionOpNode = {
    DispatchKeyword <key:Id> <attrs:("(" <AtLeastOne<Param>> ")")?> ";" => ActionOpNode::DispatchAction(key, attrs)
};

AtLeastOne<T> : Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

CommaList<T> : Vec<T> = {
    <v:(<T> ",")*> <e:T?> => {
        match e {
            None => v,
            Some(e) => {
                let mut v = v;
                v.push(e);
                v
            }
        }
    }
};

#[inline]
Param : (String, ExprValue) = {
    <ident:Id> "=" <val:ExprValue> =>
    {
        let ident = ident.into();
        
        (ident, val)
    }
};

#[inline]
ParamList : Vec<(String, ExprValue)> = {
    <v:(<Param> ",")*> <e:Param?> => {
        let mut v = v;
        if let Some(e) = e { v.push(e); }
        v
    }
};

//    <events:("|" <Id> "|" <params:("(" <AtLeastOne<Id> ")"> )?>

ElementNodeEvent: (Option<String>, Option<Vec<String>>, Option<Vec<ActionOpNode>>) = 
    <event_name:Id?> "|" <params:AtLeastOne<Id>?> "|" "{" <act_ops:(ActionOpNode+)?> "}" => (event_name, params, act_ops);

ElementNode : ContentNodeType = {
    <element_ty:Id> "(" <attrs:AtLeastOne<Param>?> ")"
    <events:(ElementNodeEvent+)?>
    "{" <children:ContentNodeType*> "}" =>
        {
            let element_ty = element_ty.into();
            let element_key = allocate_element_key();

            ContentNodeType::ElementNode(
                ast::ElementType {
                    element_ty: element_ty,
                    element_key: Some(element_key),
                    attrs: attrs,
                    children: Some(children),
                    events: events
                }
            )
        },
    <element_ty:Id> "{" <children:ContentNodeType*> "}" =>
        {
            let element_ty = element_ty.into();
            let element_key = allocate_element_key();

            ContentNodeType::ElementNode(
                ast::ElementType {
                    element_ty: element_ty,
                    element_key: Some(element_key),
                    attrs: None,
                    children: Some(children),
                    events: None
                }
            )
        }
};

// Scope: store/

DefaultScopeNodeType : DefaultScopeNodeType = {
    LetKeyword <var:Id> <expr:("=" <ExprValue>)?> ";" => DefaultScopeNodeType::LetNode(var.into(), expr),
    ApiKeyword <api_scope:Id> "{" <children:ApiNodeType*> "}" => DefaultScopeNodeType::ApiRootNode(api_scope.into(), Some(children)),
    <name:Id> "{" <children:ScopeNodeType*> "}" => DefaultScopeNodeType::ScopeNode(name.into(), children)
};

// Scope: store/{scope+}

ScopeNodeType : ScopeNodeType = {
    LetKeyword <var:Id> <expr:("=" <ExprValue>)?> ";" => ScopeNodeType::LetNode(var.into(), expr),
    ActionNode,
    ApiKeyword "{" <children:ApiNodeType*> "}" => ScopeNodeType::ApiNode(children),
    <name:Id> "{" <children:ScopeNodeType*> "}" => ScopeNodeType::ScopeNode(name.into(), children)
};

ActionNode : ScopeNodeType = {
    ActionKeyword <name:Id> <expr:("=>" <ExprValue>)?> ";" => {
        // TODO: Support other expression types
        if let Some(expr) = expr {
            ScopeNodeType::ActionNode(name.into(), Some(ActionStateExprType::SimpleReducerKeyExpr(expr)))
        } else {
            ScopeNodeType::ActionNode(name.into(), None)
        }
    }
};

// Scope: store/{scope*}/api

ApiNodeType : ApiNodeType = {
    MethodsKeyword "{" <methods:MethodType*> "}" => ApiNodeType::MethodsNode(methods),
    ResourceKeyword <name:Id> => ApiNodeType::ResourceNode( api::ApiResourceData { resource_name: name.into(), children: None } ),
    ResourceKeyword <name:Id> "{" <children:ApiNodeType*> "}" => ApiNodeType::ResourceNode(
        api::ApiResourceData { resource_name: name.into(), children: Some(children) }
    ),
    <method:MethodType> => ApiNodeType::BareMethodNode( method )
};

MethodType : MethodType = {
    GetKeyword ";" => MethodType::Get,
    PostKeyword ";" => MethodType::Post,
    PutKeyword ";" => MethodType::Put,
    DelKeyword ";" => MethodType::Delete,
    PatchKeyword ";" => MethodType::Patch
};

Loc<Inner> : Loc<Inner, (usize, usize)> = <s:@L> <inner:Inner> <e:@R> => Loc { pos: (s, e), inner: inner };

extern {
    type Location = usize;
    type Error = token::Error;
    
    enum Token {
        "=>" => Token::HashRocket,
        "|" => Token::Pipe,

        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        "," => Token::Comma,
        "=" => Token::Equals,
        ";" => Token::Semi,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Mul,
        "/" => Token::Div,

        Id => Token::Identifier(<String>),
        LitNum => Token::LiteralNumber(<i32>),
        LitStr => Token::LiteralString(<String>),
        UseKeyword => Token::UseKeyword,
        LetKeyword => Token::LetKeyword,
        ValueKeyword => Token::ValueKeyword,
        
        ComponentKeyword => Token::ComponentKeyword,
        StoreKeyword => Token::StoreKeyword,
        ActionKeyword => Token::ActionKeyword,
        ApiKeyword => Token::ApiKeyword,
        ResourceKeyword => Token::ResourceKeyword,
        MethodsKeyword => Token::MethodsKeyword,

        GetKeyword => Token::GetKeyword,
        PostKeyword => Token::PostKeyword,
        PutKeyword => Token::PutKeyword,
        DelKeyword => Token::DelKeyword,
        PatchKeyword => Token::PatchKeyword,

        EventKeyword => Token::EventKeyword,
        DispatchKeyword => Token::DispatchKeyword
    }
}
