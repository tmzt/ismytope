

use itertools::Itertools;

use parser::ast::*;
use parser::store::{DefaultScopeNodeType, ScopeNodeType, ActionStateExprType};
use parser::api::{self, ApiNodeType, MethodType};
use parser::loc::Loc;
use parser::token::{self, Token};
use parser::util::allocate_element_key;

grammar;

pub Template: Template = {
    <children:Loc<NodeType>*> => Template { children: children }
};

NodeType: NodeType = {
    UseStmtNode,
    ComponentDefinitionNode,
    StoreNode,
    <content:ContentNodeType> => NodeType::ContentNode(content)
};

//#[inline]
ContentNodeType : ContentNodeType = {
    ForKeyword <for_var:(<Id> InKeyword)?> <coll_var:ExprValue> "{" <body:ContentNodeType*> "}" => ContentNodeType::ForNode(for_var, coll_var, Some(body)),

    "(" "{" <node:ContentNodeType> "}" ")" => node.clone(),
    "(" <expr:ExprValue> ")" => ContentNodeType::ExpressionValueNode(expr.clone(), allocate_element_key()),

    ElementNode,
    <num:LitNum> => ContentNodeType::ExpressionValueNode(ExprValue::LiteralNumber(num), allocate_element_key()),
    <lit:LitStr> => ContentNodeType::ExpressionValueNode(ExprValue::LiteralString(lit), allocate_element_key()),
    <lit:LitBool> => ContentNodeType::ExpressionValueNode(ExprValue::LiteralBool(lit), allocate_element_key())
};

// Store defines a default scope which restricts the type of nodes allowed
StoreNode : NodeType =
{
    StoreKeyword "{" <children:DefaultScopeNodeType*> "}" => NodeType::StoreNode(children)
};

UseStmtNode : NodeType =
{
    UseKeyword <package:Id> ";" =>
    {
        let package = package.into();

        NodeType::UseStmtNode(
            UseStmtType {
                package: package
            }
        )
    }
};

ComponentDefinitionNode: NodeType =
{
    ComponentKeyword <name:Id> "(" <inputs:CommaList<Id>> ")" "{"
        <children:NodeType*>
    "}" =>
    {
        NodeType::ComponentDefinitionNode(
            ComponentDefinitionType {
                name: name.into(),
                inputs: Some(inputs),
                children: Some(children)
            }
        )
    }
};

ExprOp : ExprOp =
{
    "+" => ExprOp::Add,
    "-" => ExprOp::Sub,
    "*" => ExprOp::Mul,
    "/" => ExprOp::Div
};

ExprValue : ExprValue =
{
    "(" "{" <node:ContentNodeType> "}" ")" => ExprValue::ContentNode(Box::new(node)),    
    <l:ExprValue> "+" <r:ExprFactor> => ExprValue::Expr(ExprOp::Add, Box::new(l), Box::new(r)),
    <l:ExprValue> "-" <r:ExprFactor> => ExprValue::Expr(ExprOp::Sub, Box::new(l), Box::new(r)),
    ExprFactor
};

ExprFactor : ExprValue =
{
    <l:ExprFactor> "*" <r:ExprTerm> => ExprValue::Expr(ExprOp::Mul, Box::new(l), Box::new(r)),
    <l:ExprFactor> "/" <r:ExprTerm> => ExprValue::Expr(ExprOp::Div, Box::new(l), Box::new(r)),
    ExprTerm,
    VarOrMethodPath
};

ExprTerm : ExprValue =
{
    "(" <expr:ExprValue> ")" => ExprValue::Group(Some(Box::new(expr.into()))),
    "{" <props:CommaList<ObjectProp>> "}" => ExprValue::LiteralObject(Some(props.clone())),
    "[" <items:CommaList<ExprValue>> "]" => ExprValue::LiteralArray(Some(items)),

    <n:LitNum> => ExprValue::LiteralNumber(n),
    <b:LitBool> => ExprValue::LiteralBool(b),

    ValueKeyword => ExprValue::SymbolReference(Symbol::unresolved("value")),

    // <sym:VarPath> => ExprValue::SymbolReference(sym),

    // <path:AtLeastOneOf<".", Id>> => {
    //     let ident = path.join(".");
    //     match path.len() {
    //         1 => ExprValue::SymbolReference(Symbol::unresolved(&ident)),
    //         _ => ExprValue::SymbolReference(Symbol::unresolved_path(&ident))
    //     } 
    // },
    <s:LitStr> => ExprValue::LiteralString(s),

    // VarOrMethodPath

    // <p:IterMethodPipelinePath> => {
    //     let has_methods = p.iter().any(|c| if let IterMethodPipelinePath::Method(..) = c { false} else { true});
    //     if has_methods {
    //         ExprValue::IterMethodPipeline(Some(p))
    //     } else {
    //         let ident = path.join(".");
    //         let sym = match path.len() {
    //             1 => Symbol::unresolved(&ident),
    //             _ => Symbol::unresolved_path(&ident)
    //         };
    //         ExprValue::SymbolReference(sym)
    //     }
    // }
};

ActionOpNode: ActionOpNode = {
    DispatchKeyword <key:Id> <attrs:("(" <AtLeastOne<ObjectProp>> ")")?> ";" => ActionOpNode::DispatchAction(key, attrs)
};

AtLeastOne<T> : Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

AtLeastOneOf<S, T> : Vec<T> = {
    <v:(<T> S)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

#[inline]
AtLeastTwoOf<S, T> : Vec<T> = {
    <v:(<T> S)*> <a:T> S <b:T> => {
        let mut v = v;
        v.push(a);
        v.push(b);
        v
    }
};

CommaList<T> : Vec<T> = {
    <v:(<T> ",")*> <e:T?> => {
        match e {
            None => v,
            Some(e) => {
                let mut v = v;
                v.push(e);
                v
            }
        }
    }
};

#[inline]
ElementLens : LensExprType = {
    // TODO: Support element key
    ForKeyword <coll:Id> => LensExprType::ForLens(None, ExprValue::SymbolReference(Symbol::unresolved(&coll))),
    ForKeyword <ele_key:Id> InKeyword <coll:Id> => LensExprType::ForLens(Some(ele_key.into()), ExprValue::SymbolReference(Symbol::unresolved(&coll))),
    GetKeyword <prop:Id> => LensExprType::GetLens(prop.to_owned(), ExprValue::SymbolReference(Symbol::unresolved(&prop)))
};

#[inline]
ElementProp: Prop = {
    ValueKeyword "=" <val:ExprValue> => { ("value".into(), Some(val)) },
    ForKeyword "=" <val:ExprValue> => { ("for".into(), Some(val)) },
    <ident:Id> "=" <val:ExprValue> => { (ident.into(), Some(val)) }
};

#[inline]
ObjectProp: Prop = {
    ValueKeyword ":" <val:ExprValue> => { ("value".into(), Some(val)) },
    <ident:Id> ":" <val:ExprValue> => { (ident.into(), Some(val)) }
};

#[inline]
ElementParamList : (Option<LensExprType>, Option<Vec<Prop>>) = {
    <lens:ElementLens?> <v:(<ElementProp> ",")*> <e:ElementProp?> => {
        let v = match e {
            None => v,
            Some(e) => {
                let mut v = v;
                v.push(e);
                v
            }
        };

        (lens, Some(v))
    }
};

#[inline]
VarPath : Symbol = {
    <path:AtLeastOneOf<".", Id>> => {
        let ident = path.join(".");
        match path.len() {
            1 => Symbol::unresolved(&ident),
            _ => Symbol::unresolved_path(&ident)
        } 
    }
};

#[inline]
IterMethodPipelineComponent : IterMethodPipelineComponent = {
    <id:Id> "(" <params:CommaList<ExprFactor>> ")" => IterMethodPipelineComponent::Method(id.to_owned(), if params.len() > 0 { Some(params) } else { None }),
    <id:Id> => IterMethodPipelineComponent::PathComponent(id.to_owned())
};

// #[inline]
// IterMethodPipelinePath : ExprValue = {
//     <path:AtLeastTwoOf<".", IterMethodPipelineComponent>> => {
//         ExprValue::IterMethodPipeline(Some(path))
//     }
// };

#[inline]
VarOrMethodPath : ExprValue = {
    <e:(<ExprTerm> ".")?> <path:AtLeastOneOf<".", IterMethodPipelineComponent>> => {
        let has_methods = path.iter().any(|c| if let &IterMethodPipelineComponent::Method(..) = c { true } else { false });
        if has_methods {
            ExprValue::IterMethodPipeline(e.as_ref().map(|b| Box::new(b.to_owned())), Some(path))
        } else {
            let path: Vec<_> = path.iter().map(|c| match c { &IterMethodPipelineComponent::PathComponent(ref s) => s.to_owned(), _ => "undefined".to_owned() }).collect();
            let ident = path.join(".");
            let sym = match path.len() {
                1 => Symbol::unresolved(&ident),
                _ => Symbol::unresolved_path(&ident)
            };
            ExprValue::SymbolReference(sym)
        }
    }
};


#[inline]
Param : (String, ExprValue) = {
    <ident:Id> "=" <val:ExprValue> =>
    {
        let ident = ident.into();
        
        (ident, val)
    }
};

//    <events:("|" <Id> "|" <params:("(" <AtLeastOne<Id> ")"> )?>

ElementBindingNode: ElementBindingNodeType = {
    BindKeyword <sym:VarPath> AsKeyword <id:Id> => ElementBindingNodeType::ElementValueBindingAsNode(id.to_owned(), sym, Symbol::unresolved(&id)),
    BindKeyword <sym:VarPath> => ElementBindingNodeType::ElementValueBindingNode("binding".into(), sym),

    "|" <params:AtLeastOne<Id>?> "|" "{" <act_ops:(ActionOpNode+)?> "}" => ElementBindingNodeType::ElementEventBindingNode(EventHandler::DefaultEvent(params, act_ops)),
    <event_name:Id> "|" <params:AtLeastOne<Id>?> "|" "{" <act_ops:(ActionOpNode+)?> "}" => ElementBindingNodeType::ElementEventBindingNode(EventHandler::Event(event_name, params, act_ops))
};

ElementNode : ContentNodeType = {
    <element_ty:Id> "(" <params:ElementParamList> ")"
    <bindings:(ElementBindingNode+)?>
    "{" <children:(ContentNodeType+)?> "}" =>
        {
            let element_ty = element_ty.into();
            let element_key = allocate_element_key();

            let lens = params.0;
            let attrs = params.1;

            ContentNodeType::ElementNode(
                ElementType {
                    element_ty: element_ty,
                    element_key: element_key,
                    attrs: attrs,
                    lens: lens,
                    children: children,
                    bindings: bindings
                }
            )
        },
    <element_ty:Id> "{" <children:ContentNodeType*> "}" =>
        {
            let element_ty = element_ty.into();
            let element_key = allocate_element_key();

            ContentNodeType::ElementNode(
                ElementType {
                    element_ty: element_ty,
                    element_key: element_key,
                    attrs: None,
                    lens: None,
                    children: Some(children),
                    bindings: None
                }
            )
        }
};

// Scope: store/

DefaultScopeNodeType : DefaultScopeNodeType = {
    LetKeyword <var:Id> <expr:("=" <ExprValue>)?> ";" => DefaultScopeNodeType::LetNode(var.into(), expr),
    ApiKeyword <api_scope:Id> "{" <children:ApiNodeType*> "}" => DefaultScopeNodeType::ApiRootNode(api_scope.into(), Some(children)),
    <name:Id> "{" <children:ScopeNodeType*> "}" => DefaultScopeNodeType::ScopeNode(name.into(), children)
};

// Scope: store/{scope+}

ScopeNodeType : ScopeNodeType = {
    LetKeyword <var:Id> <expr:("=" <ExprValue>)?> ";" => ScopeNodeType::LetNode(var.into(), expr),
    ActionNode,
    ApiKeyword "{" <children:ApiNodeType*> "}" => ScopeNodeType::ApiNode(children),
    <name:Id> "{" <children:ScopeNodeType*> "}" => ScopeNodeType::ScopeNode(name.into(), children)
};

ActionNodeParamList: Vec<String> = "(" <CommaList<Id>> ")";

ActionNode : ScopeNodeType = {
    ActionKeyword <name:Id> <params:ActionNodeParamList?> <expr:("=>" <ExprValue>)?> ";" => {
        let expr = expr.as_ref().map(|expr| ActionStateExprType::SimpleReducerKeyExpr(expr.to_owned()));
        let has_params = params.as_ref().map_or(false, |params| params.len() > 0);
        let params = if has_params { params } else { None };
        ScopeNodeType::ActionNode(name.to_owned(), expr, params)
    }
};

// Scope: store/{scope*}/api

ApiNodeType : ApiNodeType = {
    MethodsKeyword "{" <methods:MethodType*> "}" => ApiNodeType::MethodsNode(methods),
    ResourceKeyword <name:Id> => ApiNodeType::ResourceNode( api::ApiResourceData { resource_name: name.into(), children: None } ),
    ResourceKeyword <name:Id> "{" <children:ApiNodeType*> "}" => ApiNodeType::ResourceNode(
        api::ApiResourceData { resource_name: name.into(), children: Some(children) }
    ),
    <method:MethodType> => ApiNodeType::BareMethodNode( method )
};

MethodType : MethodType = {
    GetKeyword ";" => MethodType::Get,
    PostKeyword ";" => MethodType::Post,
    PutKeyword ";" => MethodType::Put,
    DelKeyword ";" => MethodType::Delete,
    PatchKeyword ";" => MethodType::Patch
};

Loc<Inner> : Loc<Inner, (usize, usize)> = <s:@L> <inner:Inner> <e:@R> => Loc { pos: (s, e), inner: inner };

extern {
    type Location = usize;
    type Error = token::Error;
    
    enum Token {
        "=>" => Token::HashRocket,
        "|" => Token::Pipe,

        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,
        "[" => Token::OpenBracket,
        "]" => Token::CloseBracket,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        "," => Token::Comma,
        "." => Token::Dot,
        "=" => Token::Equals,
        ":" => Token::Colon,
        ";" => Token::Semi,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Mul,
        "/" => Token::Div,

        Id => Token::Identifier(<String>),
        LitNum => Token::LiteralNumber(<i32>),
        LitStr => Token::LiteralString(<String>),
        LitBool => Token::LiteralBool(<bool>),
        UseKeyword => Token::UseKeyword,
        LetKeyword => Token::LetKeyword,
        ForKeyword => Token::ForKeyword,
        InKeyword => Token::InKeyword,
        BindKeyword => Token::BindKeyword,
        AsKeyword => Token::AsKeyword,
        ValueKeyword => Token::ValueKeyword,
        
        ComponentKeyword => Token::ComponentKeyword,
        StoreKeyword => Token::StoreKeyword,
        ActionKeyword => Token::ActionKeyword,
        ApiKeyword => Token::ApiKeyword,
        ResourceKeyword => Token::ResourceKeyword,
        MethodsKeyword => Token::MethodsKeyword,

        GetKeyword => Token::GetKeyword,
        PostKeyword => Token::PostKeyword,
        PutKeyword => Token::PutKeyword,
        DelKeyword => Token::DelKeyword,
        PatchKeyword => Token::PatchKeyword,

        EventKeyword => Token::EventKeyword,
        DispatchKeyword => Token::DispatchKeyword,

        // TrueKeyword => Token::LiteralBool(true),
        // FalseKeyword => Token::LiteralBool(false),
    }
}
