
use parser::ast::*;
use parser::store::{DefaultScopeNodeType, ScopeNodeType, ActionStateExprType};
use parser::api::{self, ApiNodeType, MethodType};
use parser::loc::Loc;
use parser::token::{self, Token};
use parser::util::allocate_element_key;

grammar;

pub Template: Template = {
    <children:Loc<NodeType>*> => Template { children: children }
};

NodeType: NodeType = {
    UseStmtNode,
    ComponentDefinitionNode,
    StoreNode,
    <content:ContentNodeType> => NodeType::ContentNode(content)
};

//#[inline]
ContentNodeType : ContentNodeType = {
    ForKeyword <for_var:(<Id> InKeyword)?> <coll_var:ExprValue> "{" <body:ContentNodeType*> "}" => ContentNodeType::ForNode(for_var, coll_var, Some(body)),

//    ForKeyword <ele:(<Id> InKeyword)?> <coll:Id> "{" <body:(<ContentNodeType*>)?> "}"
//         => ContentNodeType::ForNode(ele, coll.clone(), body),

    "(" "{" <node:ContentNodeType> "}" ")" => node.clone(),
    "(" <expr:ExprValue> ")" => ContentNodeType::ExpressionValueNode(expr.clone(), allocate_element_key()),

    ElementNode,
    <num:LitNum> => ContentNodeType::ExpressionValueNode(ExprValue::LiteralNumber(num), allocate_element_key()),
    <lit:LitStr> => ContentNodeType::ExpressionValueNode(ExprValue::LiteralString(lit), allocate_element_key())
};

// Store defines a default scope which restricts the type of nodes allowed
StoreNode : NodeType =
{
    StoreKeyword "{" <children:DefaultScopeNodeType*> "}" => NodeType::StoreNode(children)
};

UseStmtNode : NodeType =
{
    UseKeyword <package:Id> ";" =>
    {
        let package = package.into();

        NodeType::UseStmtNode(
            UseStmtType {
                package: package
            }
        )
    }
};

ComponentDefinitionNode: NodeType =
{
    // ComponentKeyword <name:Id> "{"
    //     <children:NodeType*>
    // "}" =>
    // {
    //     let definition_name = name.into();

    //     NodeType::ComponentDefinitionNode(
    //         ComponentDefinitionType {
    //             name: definition_name,
    //             inputs: None,
    //             children: Some(children)
    //         }
    //     )
    // },
    ComponentKeyword <name:Id> "(" <inputs:CommaList<Id>> ")" "{"
        <children:NodeType*>
    "}" =>
    {
        NodeType::ComponentDefinitionNode(
            ComponentDefinitionType {
                name: name.into(),
                inputs: Some(inputs),
                children: Some(children)
            }
        )
    }
};

ExprOp : ExprOp =
{
    "+" => ExprOp::Add,
    "-" => ExprOp::Sub,
    "*" => ExprOp::Mul,
    "/" => ExprOp::Div
};

ExprValue : ExprValue =
{
//    "(" <expr:ExprValue> ")" => expr.clone(),
    "(" "{" <node:ContentNodeType> "}" ")" => ExprValue::ContentNode(Box::new(node)),
    "[" <items:CommaList<ExprValue>> "]" => ExprValue::LiteralArray(Some(items)),
    
    <l:ExprValue> "+" <r:ExprFactor> => ExprValue::Expr(ExprOp::Add, Box::new(l), Box::new(r)),
    <l:ExprValue> "-" <r:ExprFactor> => ExprValue::Expr(ExprOp::Sub, Box::new(l), Box::new(r)),
//    "|" <attrs:("(" <AtLeastOne<Id>> ")")?> "|" "{" <action_ops:ActionOpNode*> "}" => ExprValue::Action(attrs, Some(action_ops)),
    ExprFactor
};

ExprFactor : ExprValue =
{
    <l:ExprFactor> "*" <r:ExprTerm> => ExprValue::Expr(ExprOp::Mul, Box::new(l), Box::new(r)),
    <l:ExprFactor> "/" <r:ExprTerm> => ExprValue::Expr(ExprOp::Div, Box::new(l), Box::new(r)),
    ExprTerm
};

ExprTerm : ExprValue =
{
    <n:LitNum> => ExprValue::LiteralNumber(n),
//    "(" <ExprValue> ")",
    ValueKeyword => ExprValue::DefaultVariableReference,
    <ident:Id> => ExprValue::SymbolReference(Symbol::unresolved(&ident)),
    <varpath:VarPath> => {
        let sym_path = varpath.iter().map(|ref ident| Symbol::unresolved(ident)).collect();
        ExprValue::SymbolPathReference(sym_path)
    },
    <s:LitStr> => ExprValue::LiteralString(s),
};

ActionOpNode: ActionOpNode = {
    DispatchKeyword <key:Id> <attrs:("(" <AtLeastOne<ColonProp>> ")")?> ";" => ActionOpNode::DispatchAction(key, attrs)
};

AtLeastOne<T> : Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

// VarPath : String = {
//     <v:(<Id> ".")*> <part:Id> => {
//         let mut parts = v.join(".");
//         parts.push_str(&part);
//         parts
//     }
// };

VarPath : Vec<String> = {
    <v:(<Id> ".")+> <e:Id> => {
        let mut v = v;
        v.push(e);
        v
    }
};

CommaList<T> : Vec<T> = {
    <v:(<T> ",")*> <e:T?> => {
        match e {
            None => v,
            Some(e) => {
                let mut v = v;
                v.push(e);
                v
            }
        }
    }
};

#[inline]
ElementLens : LensExprType = {
    // TODO: Support element key
    ForKeyword <coll:Id> => LensExprType::ForLens(None, ExprValue::SymbolReference(Symbol::unresolved(&coll))),
    ForKeyword <ele_key:Id> InKeyword <coll:Id> => LensExprType::ForLens(Some(ele_key.into()), ExprValue::SymbolReference(Symbol::unresolved(&coll))),
    GetKeyword <prop:Id> => LensExprType::GetLens(prop.to_owned(), ExprValue::SymbolReference(Symbol::unresolved(&prop)))
};

#[inline]
ElementProp: Prop = {
    ValueKeyword "=" <val:ExprValue> => { ("value".into(), Some(val)) },
    ForKeyword "=" <val:ExprValue> => { ("for".into(), Some(val)) },
    <ident:Id> "=" <val:ExprValue> => { (ident.into(), Some(val)) }
};

#[inline]
ColonProp: Prop = {
    ValueKeyword ":" <val:ExprValue> => { ("value".into(), Some(val)) },
    <ident:Id> ":" <val:ExprValue> => { (ident.into(), Some(val)) }
};

#[inline]
ElementParamList : (Option<LensExprType>, Option<Vec<Prop>>) = {
    <lens:ElementLens?> <v:(<ElementProp> ",")*> <e:ElementProp?> => {
        let v = match e {
            None => v,
            Some(e) => {
                let mut v = v;
                v.push(e);
                v
            }
        };

        (lens, Some(v))
    }
};

#[inline]
Param : (String, ExprValue) = {
    <ident:Id> "=" <val:ExprValue> =>
    {
        let ident = ident.into();
        
        (ident, val)
    }
};

//    <events:("|" <Id> "|" <params:("(" <AtLeastOne<Id> ")"> )?>

ElementBindingNode: ElementBindingNodeType = {
    BindKeyword <key:Id> => ElementBindingNodeType::ElementValueBindingNode(key.to_owned(), Symbol::unresolved(&key)),
    "|" <params:AtLeastOne<Id>?> "|" "{" <act_ops:(ActionOpNode+)?> "}" => ElementBindingNodeType::ElementEventBindingNode(EventHandler::DefaultEvent(params, act_ops)),
    <event_name:Id> "|" <params:AtLeastOne<Id>?> "|" "{" <act_ops:(ActionOpNode+)?> "}" => ElementBindingNodeType::ElementEventBindingNode(EventHandler::Event(event_name, params, act_ops))
};

ElementNode : ContentNodeType = {
    <element_ty:Id> "(" <params:ElementParamList> ")"
    <bindings:(ElementBindingNode+)?>
    "{" <children:(ContentNodeType+)?> "}" =>
        {
            let element_ty = element_ty.into();
            let element_key = allocate_element_key();

            let lens = params.0;
            let attrs = params.1;

            ContentNodeType::ElementNode(
                ElementType {
                    element_ty: element_ty,
                    element_key: element_key,
                    attrs: attrs,
                    lens: lens,
                    children: children,
                    bindings: bindings
                }
            )
        },
    <element_ty:Id> "{" <children:ContentNodeType*> "}" =>
        {
            let element_ty = element_ty.into();
            let element_key = allocate_element_key();

            ContentNodeType::ElementNode(
                ElementType {
                    element_ty: element_ty,
                    element_key: element_key,
                    attrs: None,
                    lens: None,
                    children: Some(children),
                    bindings: None
                }
            )
        }
};

// Scope: store/

DefaultScopeNodeType : DefaultScopeNodeType = {
    LetKeyword <var:Id> <expr:("=" <ExprValue>)?> ";" => DefaultScopeNodeType::LetNode(var.into(), expr),
    ApiKeyword <api_scope:Id> "{" <children:ApiNodeType*> "}" => DefaultScopeNodeType::ApiRootNode(api_scope.into(), Some(children)),
    <name:Id> "{" <children:ScopeNodeType*> "}" => DefaultScopeNodeType::ScopeNode(name.into(), children)
};

// Scope: store/{scope+}

ScopeNodeType : ScopeNodeType = {
    LetKeyword <var:Id> <expr:("=" <ExprValue>)?> ";" => ScopeNodeType::LetNode(var.into(), expr),
    ActionNode,
    ApiKeyword "{" <children:ApiNodeType*> "}" => ScopeNodeType::ApiNode(children),
    <name:Id> "{" <children:ScopeNodeType*> "}" => ScopeNodeType::ScopeNode(name.into(), children)
};

ActionNodeParamList: Vec<String> = "(" <CommaList<Id>> ")";

ActionNode : ScopeNodeType = {
    ActionKeyword <name:Id> <params:ActionNodeParamList?> <expr:("=>" <ExprValue>)?> ";" => {
        let expr = expr.as_ref().map(|expr| ActionStateExprType::SimpleReducerKeyExpr(expr.to_owned()));
        let has_params = params.as_ref().map_or(false, |params| params.len() > 0);
        let params = if has_params { params } else { None };
        ScopeNodeType::ActionNode(name.to_owned(), expr, params)
    }
};

// Scope: store/{scope*}/api

ApiNodeType : ApiNodeType = {
    MethodsKeyword "{" <methods:MethodType*> "}" => ApiNodeType::MethodsNode(methods),
    ResourceKeyword <name:Id> => ApiNodeType::ResourceNode( api::ApiResourceData { resource_name: name.into(), children: None } ),
    ResourceKeyword <name:Id> "{" <children:ApiNodeType*> "}" => ApiNodeType::ResourceNode(
        api::ApiResourceData { resource_name: name.into(), children: Some(children) }
    ),
    <method:MethodType> => ApiNodeType::BareMethodNode( method )
};

MethodType : MethodType = {
    GetKeyword ";" => MethodType::Get,
    PostKeyword ";" => MethodType::Post,
    PutKeyword ";" => MethodType::Put,
    DelKeyword ";" => MethodType::Delete,
    PatchKeyword ";" => MethodType::Patch
};

Loc<Inner> : Loc<Inner, (usize, usize)> = <s:@L> <inner:Inner> <e:@R> => Loc { pos: (s, e), inner: inner };

extern {
    type Location = usize;
    type Error = token::Error;
    
    enum Token {
        "=>" => Token::HashRocket,
        "|" => Token::Pipe,

        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,
        "[" => Token::OpenBracket,
        "]" => Token::CloseBracket,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        "," => Token::Comma,
        "." => Token::Dot,
        "=" => Token::Equals,
        ":" => Token::Colon,
        ";" => Token::Semi,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Mul,
        "/" => Token::Div,

        Id => Token::Identifier(<String>),
        LitNum => Token::LiteralNumber(<i32>),
        LitStr => Token::LiteralString(<String>),
        UseKeyword => Token::UseKeyword,
        LetKeyword => Token::LetKeyword,
        ForKeyword => Token::ForKeyword,
        InKeyword => Token::InKeyword,
        BindKeyword => Token::BindKeyword,
        ValueKeyword => Token::ValueKeyword,
        
        ComponentKeyword => Token::ComponentKeyword,
        StoreKeyword => Token::StoreKeyword,
        ActionKeyword => Token::ActionKeyword,
        ApiKeyword => Token::ApiKeyword,
        ResourceKeyword => Token::ResourceKeyword,
        MethodsKeyword => Token::MethodsKeyword,

        GetKeyword => Token::GetKeyword,
        PostKeyword => Token::PostKeyword,
        PutKeyword => Token::PutKeyword,
        DelKeyword => Token::DelKeyword,
        PatchKeyword => Token::PatchKeyword,

        EventKeyword => Token::EventKeyword,
        DispatchKeyword => Token::DispatchKeyword
    }
}
